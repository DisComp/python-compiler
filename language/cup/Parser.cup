package com.language.parser;

import java.util.*;
import java_cup.runtime.*;
import com.language.model.expression.*;
import com.language.exceptions.*;

/* Numbers */
terminal String INTEGER, FLOAT, LONG_INT;

/* Arithmetic operators */
terminal String PLUS, MINUS, TIMES, EXP, DIV, DIV_INT, MOD;

/* Bitwise operators */
terminal String AND_BIT, OR_BIT, XOR_BIT, NOT_BIT, LSHIFT, RSHIFT;

/* Strings */
terminal String STRING, ESCAPE, TAB;

/* Boolean */
terminal String TRUE, FALSE;

/* Boolean operators */
terminal String AND, OR, NOT, EQUALS, DISTINCT, LESS, GREATER, LESS_EQUAL, GREATER_EQUAL;

/* Punctuation chars */
terminal String POINT, SEMICOLON, COMMA, COLON, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, ASSIGN;

/* Structure control */
terminal String IF, ELSE, WHILE, BREAK, CONTINUE, FOR, IN, DEF, RETURN;

/* Predefined functions */
	
/* Dictionaries */
terminal String HAS_KEY_FUNC, ITEMS_FUNC, KEYS_FUNC, POP_FUNC, VALUES_FUNC;
	
/* Strings */
terminal String COUNT_FUNC, FIND_FUNC, JOIN_FUNC, SPLIT_FUNC, REPLACE_FUNC, LENGTH_FUNC;

/* Lists */
terminal String APPEND_FUNC, EXTEND_FUNC, INDEX_FUNC, INSERT_FUNC, SIZE_FUNC;
	
/* Input/Output */
terminal String RAW_INPUT_FUNC, PRINT_FUNC;

/* Type conversion */
terminal String INT_FUNC, FLOAT_FUNC, STR_FUNC, TUPLE_FUNC, LIST_FUNC, DICT_FUNC;

/* Long */
terminal String LONG_FUNC;

/* String */
terminal String STRING_FUNC;
	
/* Others */
terminal String NONE; 
terminal String TYPE_FUNC; 
terminal String ID;

/* Line Terminator*/
terminal String LINE_TERMINATOR;

/* NON TERMINALS */
non terminal Expression expr;
non terminal Expression instrs;
non terminal Expression instr;
non terminal Expression indent_instrs;
non terminal Expression if_block;

non terminal Expression boolean_expr;
non terminal Expression bitwise_expr;
non terminal Expression arithmetical_expr;
non terminal Expression numerical_expr;
non terminal Expression literal_expr;

precedence left OR;
precedence left AND;
precedence left NOT;
precedence left EQUALS, DISTINCT, LESS, GREATER, LESS_EQUAL, GREATER_EQUAL;
precedence left OR_BIT;
precedence left XOR_BIT;
precedence left AND_BIT;
precedence left LSHIFT, RSHIFT;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, DIV_INT, MOD;
precedence left NOT_BIT;
precedence left EXP;
precedence left ASSIGN;
precedence left IF;

start with expr;

/* Instructions section */
instrs ::= instr:i LINE_TERMINATOR
			|
           instr:i LINE_TERMINATOR instrs:is;

indent_instrs ::= TAB instr: i LINE_TERMINATOR 
				| TAB instr: i LINE_TERMINATOR indent_instrs:iis;
				 
instr ::= expr; // TODO: change this expression //

/* If block */
if_block ::= IF expr: e COLON LINE_TERMINATOR indent_instrs;


boolean_expr ::=  boolean_expr: l OR  boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.OR, "or", l, r); :}
				| boolean_expr: l AND boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.AND, "and", l, r); :}
				| NOT boolean_expr: l {: RESULT = BooleanExpression.create(BooleanExpression.NOT, "not", l); :}
				| boolean_expr: l EQUALS boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.EQUALS, "==", l, r); :}
				| boolean_expr: l DISTINCT boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.DISTINCT, "!=", l, r); :}
				| boolean_expr: l LESS boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.LESS, "<", l, r); :}
				| boolean_expr: l GREATER boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.GREATER, ">", l, r); :}
				| boolean_expr: l LESS_EQUAL boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.LESS_EQUAL, "<=", l, r); :}
				| boolean_expr: l GREATER_EQUAL boolean_expr: r {: RESULT = BooleanExpression.create(BooleanExpression.GREATER_EQUAL, ">=", l, r); :}
				| bitwise_expr: x {: RESULT = x; :};	

bitwise_expr ::=    bitwise_expr: l OR_BIT  bitwise_expr: r {: RESULT = BitwiseExpression.create(BitwiseExpression.OR_BIT, "|", l, r); :}
				  | bitwise_expr: l XOR_BIT bitwise_expr: r {: RESULT = BitwiseExpression.create(BitwiseExpression.XOR_BIT, "^", l, r); :}
				  | bitwise_expr: l AND_BIT bitwise_expr: r {: RESULT = BitwiseExpression.create(BitwiseExpression.AND_BIT, "&", l, r); :}
				  | bitwise_expr: l LSHIFT  bitwise_expr: r {: RESULT = BitwiseExpression.create(BitwiseExpression.LSHIFT, "<<", l, r); :}
                  | bitwise_expr: l RSHIFT  bitwise_expr: r {: RESULT = BitwiseExpression.create(BitwiseExpression.RSHIFT, ">>", l, r); :}
                  | NOT_BIT  bitwise_expr: l {: RESULT = BitwiseExpression.create(BitwiseExpression.NOT_BIT, "~", l); :}
				  | arithmetical_expr: x {: RESULT = x; :};				  

arithmetical_expr ::=    arithmetical_expr: l PLUS    arithmetical_expr: r {: RESULT = ArithmeticalExpression.create(ArithmeticalExpression.PLUS, "+", l, r); :}
				       | arithmetical_expr: l MINUS   arithmetical_expr: r {: RESULT = ArithmeticalExpression.create(ArithmeticalExpression.MINUS, "-", l, r); :}
					   | arithmetical_expr: l TIMES   arithmetical_expr: r {: RESULT = ArithmeticalExpression.create(ArithmeticalExpression.TIMES, "*", l, r); :} 
				       | arithmetical_expr: l DIV     arithmetical_expr: r {: RESULT = ArithmeticalExpression.create(ArithmeticalExpression.DIV, "/", l, r); :}
				       | arithmetical_expr: l DIV_INT arithmetical_expr: r {: RESULT = ArithmeticalExpression.create(ArithmeticalExpression.DIV_INT, "//", l, r); :}
				       | arithmetical_expr: l MOD     arithmetical_expr: r {: RESULT = ArithmeticalExpression.create(ArithmeticalExpression.MOD, "%", l, r); :}
                       | arithmetical_expr: b EXP     arithmetical_expr: e {: RESULT = ArithmeticalExpression.create(ArithmeticalExpression.EXP, "**", b, e); :}
					   | literal_expr: x {: RESULT = x; :};						  					  			  
             
literal_expr ::=  INTEGER:  i {: RESULT = LiteralExpression.createInteger(i); :}				
				| FLOAT:    f {: RESULT = LiteralExpression.createFloat(f); :}
				| LONG_INT: l {: RESULT = LiteralExpression.createLongInt(l); :}
				| STRING:   s {: RESULT = LiteralExpression.createString(s); :};

expr  ::= 
		  boolean_expr: b {: RESULT = b; :}		

		| LPAREN expr:e RPAREN
			{:
				RESULT = e;
			:}
		
		| LBRACKET expr:e RBRACKET
			{:
				RESULT = e;
			:}
			
		| TRUE:t
			{:
				RESULT = new Expression(t);
			:}
			
		| FALSE:f
			{:
				RESULT = new Expression(f);
			:}
		
		| expr:l ASSIGN expr:r
			{:
				RESULT = new Expression("=", l, r);
			:}
		;
	
	
